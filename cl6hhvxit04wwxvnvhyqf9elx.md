# My first week in a Software Engineering Immersive

Two weeks ago I made the decision to enrol in an 11 week Software Engineering Immersive with general assembly. I knew I was in for an intense few weeks cramming what could more easily be taught part-time over the course of 6 months or a year. I figured it was better to suffer in the short term with the hopes of landing a job sooner. This is either the best thing I’ve done for myself or a terrible terrible mistake. To be continued.

#### Week 1: Trains Hazing Ritual.

GA has several long-standing traditions designed to cut your teeth as a new programmer and possibly make you cry and doubt yourself in ways you never thought a railway system could inspire.

Important lessons were learned. I laughed, I cried, I cried while laughing, I got very little sleep, and I overspent on take out so that I could eat dinner while working with the unpleasant side-effect of my keyboard getting all gross and greasy.

Our first over-the-weekend homework assignment was to write a program that would function as a trip planner for a simple railway system. There are three lines with one intersecting point (thank God it was only one). The console.log should output something along the lines of You’ll be travelling from a to b. Travel from a to c on nline, passing through d e f g. Change at c then you’ll be traveling from from c to b on 6line, passing through h i and j.

Having had little to no previous experience coding before this week and having been struggling through class work on a schedule of eat, sleep, code, repeat, this simple subway system seemed like it was going to be a Sisyphean nightmare of fixing one bug and creating another. In many ways that assumption was right, but by the time I’m writing this on the 7:50 am train into the city for my Monday back at GA, I’m 1000% more confident in my programming abilities and I fully realise how important the exercise was.

My number one takeaway is to take one incredibly small step at a time and test that step before I move on. When I was getting ahead of myself and anticipating how the code that I’m writing in that moment might need to change later on, then making those changes first instead is not the efficient move I thought it was. Actually, it was the complete opposite. While I’m there, I might as well write a test console.log of what I’d expect my next line to output, then run it. It seems ridiculous at times, but it got me thinking about what I needed from my code much more explicitly than if I was trying to think through what I needed while writing the program.

My next biggest lesson was to have my functions do one thing each and to call other functions from within other functions where need be. This way I can isolate problems more easily rather than thinking I need to rewrite the program from the ground up because everything is broken.

The third most important thing I realised was that littering my program with strings is inefficient and leads to more potential problems. One spelling error can ruin everything. It’s a simple thing that is so obvious looking back, but these are the lessons you learn from experience. Sometimes things don’t sink in from just knowing them on paper, where making that mistake a few times and going through the painful process of diagnosing the problem and fixing it in every instance lets it sink in properly. This seems to be especially true for programming.